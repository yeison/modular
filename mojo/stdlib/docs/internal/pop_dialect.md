# POP Dialect Documentation

## Overview

The POP (Parametric Operations) dialect is a specialized MLIR dialect that
defines parametric operations on top of the LLVM dialect. It provides high-level
abstractions for hardware-specific operations.

The pop dialect solves two problems in Mojo:

1. It enables the definition of parametric operations (pre-elaboration) that can
   be generated by a front end parser. The elaborator then resolves these to
   concrete values that exist post-elaboration.

2. The post-elaboration IR is serialized to IR and can be used as a distributed
   code IR (e.g. sent over a wire and executed remotely) and to enable tooling.
   This requires it to be sufficiently high level that doesn't expose target
   specific information (e.g. ABIs) unnecessarily, and also means that we want
   to capture information needed by tooling (e.g. header file printing wants to
   know whether integers are signed or not).

## Key Features

- SIMD vector operations
- Memory management operations
- Array and pointer manipulation
- Type casting and conversion
- Bitwise operations
- String manipulation

## Types

### Core Types

1. `simd` - Parameterized SIMD vector type
   - Can represent scalar values using `scalar<dtype>` (equivalent to `simd<1, dtype>`)
   - Supports various DTypes including integers, floats, and booleans. These are
     modeled using the `!kgen.dtype` type.

   Examples:

   ```mlir
   !pop.simd<4, si32> // A SIMD vector type of 4 signed 32-bit integers

   !pop.simd<size, dtype> // A parameterized SIMD type
   ```

2. `array` - Parameterized array type
   - Represents statically-sized array of elements.
   - Both the size and element type are parameterized (i.e. support arbitrary
     sizes and data types).

   Examples:

   ```mlir
    !pop.array<4, scalar<f32>> // An array of four scalar floats.

    !pop.array<size, type> // A parameterized array.
   ```

3. `union` - A parameterized union type
   The `!pop.union` type is a type that can contain any one of its union
   element types. Its size is large enough to contain the largest element and
   its alignment meets the strictest of its elements' alignment requirements.
   Unlike `!kgen.variant`, this union is not discriminated.

   Example:

   ```mlir
   !pop.union<> // Empty union
   !pop.union<i32> // Union of just int32 types
   !pop.union<i32, i64> // Union of int32 and int64 types.
   ```

4. `int_literal` - Arbitrary-precision integer type for literals
   The `!pop.int_literal` type represents an infinite precision
   integer value.  It can't be materialized, but allows for arbitrary
   integer size for compile time computations.

5. `float_literal` - Arbitrary-precision float type for literals
    The `!pop.float_literal` type is for use in arbitrary precision
    compile time computations.  They are implemented as infinite precision
    rational number values.  It can't be materialized, but allows for
    arbitrary precision for compile time computations.

### Type Conversions

The dialect provides various type conversion operations:

- `cast_to_builtin` - Converts POP types to MLIR builtin types
  - The `pop.cast_to_builtin` operation casts a POP type to an MLIR builtin
    type. If the types have the same underlying implementation, then this
    operation is a no-op adaptor between two type systems. It can, for example,
    cast a `!pop.scalar` to an MLIR builtin integer or float type, or a
    `pop.simd` to a `vector.

   Example:

   ```mlir
   kgen.func @llvm_ops(%arg0: !pop.scalar<f32>) -> !pop.scalar<f32> {
     %0 = pop.cast_to_builtin %arg0 : !pop.scalar<f32> to f32
     %1 = llvm.fadd %0, %0 : f32
     %2 = pop.cast_from_builtin %1 : f32 to !pop.scalar<f32>
     kgen.return %2 : !pop.scalar<f32>
   }
   ```

- `cast_from_builtin` - Converts MLIR builtin types to POP types
    The `pop.cast_from_builtin` operation casts an MLIR builtin type to a POP
    type. If the types have the same underlying implementation, then this
    operation is a no-op adaptor between two type systems. It can, for example,
    cast an MLIR builtin integer or float type to a `!pop.scalar`, or a 1-D
    vector to `!pop.simd`.

    Example:

    ```mlir
    kgen.func @llvm_ops(%arg0: !pop.scalar<f32>) -> !pop.scalar<f32> {
      %0 = pop.cast_to_builtin %arg0 : !pop.scalar<f32> to f32
      %1 = llvm.fadd %0, %0 : f32
      %2 = pop.cast_from_builtin %1 : f32 to !pop.scalar<f32>
      kgen.return %2 : !pop.scalar<f32>
    }
    ```

    Importantly, this operation can adapt parametric constants for use in
    parametric operations.

    Example:

    ```mlir
    kgen.generator @addN<N: si32>(%arg0: !pop.scalar<si32>)
        -> !pop.scalar<si32> {
      %N = kgen.param.constant: si32 = <N>
      %rhs = pop.cast_from_builtin %N : si32 to !pop.scalar<si32>
      %result = pop.add %arg0, %rhs : !pop.scalar<f32>
      kgen.return %result : !pop.scalar<f32>
    }
    ```

- `bitcast` - Performs bitwise reinterpretation between types
    Bitcast an integer or floating point value to an integer or floating point
    value of equal bit width. The bitcast operation should not be used to cast
    between pointer types. For conversion between pointer types one should use
    `pop.pointer.bitcast`.

    Example:

    ```mlir
    %0 = pop.bitcast %a : !pop.scalar<si32> to !pop.scalar<f32>
    %1 = pop.bitcast %b : !pop.scalar<ui64> to !pop.scalar<si64>
    %2 = pop.bitcast %c : !pop.simd<4, f64> to !pop.simd<4, si64>
    %3 = pop.bitcast %d : !pop.simd<2, f64> to !pop.simd<4, f32>
    ```

## Operations

Below is an overview of supported operations.  These will get filled
out over time with a description and examples of each operation.

### Arithmetic Operations

1. Basic Arithmetic:
   - `add` - Addition
   - `sub` - Subtraction
   - `mul` - Multiplication
   - `div` - Division
   - `neg` - Negation
   - `fma` - Fused Multiply-Add

### Comparison Operations (CmpOp)

The dialect supports various comparison operations:

- `eq` - Equal to
- `ne` - Not equal to
- `lt` - Less than
- `gt` - Greater than
- `le` - Less than or equal
- `ge` - Greater than or equal
- `sgt` - Signed greater than
- `sge` - Signed greater than or equal
- `slt` - Signed less than
- `sle` - Signed less than or equal

```mlir
%result = pop.cmp %lhs, %rhs {predicate = "sgt"}
```

### Bitwise Operations

1. SIMD Bitwise:
   - `simd.and` - Bitwise AND
   - `simd.or` - Bitwise OR
   - `simd.xor` - Bitwise XOR

2. Boolean Operations:
   - `and` - Logical AND
   - `or` - Logical OR
   - `xor` - Logical XOR

### Memory Operations

1. Allocation:
   - `aligned_alloc` - Aligned heap allocation
   - `aligned_free` - Free aligned heap memory
   - `stack_allocation` - Stack memory allocation

2. Access:
   - `load` - Load from memory
   - `store` - Store to memory
   - `offset` - Pointer offset calculation

### Array Operations

1. Array Manipulation:
   - `array.create` - Create new array
   - `array.get` - Get array element
   - `array.replace` - Replace array element
   - `array.gep` - Get element pointer

### String Operations

1. String Manipulation:
   - `string.hash` - Hash string using XXH3

### Control Flow

1. Selection:
   - `select` - Conditional selection without branching

## Usage Examples

```mlir
// SIMD arithmetic
%c = pop.add %a, %b : !pop.scalar<f32>
%d = pop.mul %c, %c : !pop.simd<4, f32>

// Array operations
%arr = pop.array.create %x, %y, %z : !pop.array<3, f32>
%elem = pop.array.get %arr[1] : !pop.array<3, f32>

// Memory operations
%ptr = pop.aligned_alloc %align, %size : !pop.pointer<f32>
pop.store %value, %ptr : !pop.pointer<f32>
```
