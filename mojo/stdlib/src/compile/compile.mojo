# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
"""Provides utilities for compiling and inspecting Mojo code.

This module contains functionality for compiling Mojo functions and examining their
assembly, LLVM IR, or object code output. It is particularly useful for kernel
engineers who want to inspect the low-level implementation details of specific
functions without dealing with entire files or manual invocation of compilation
tools.

Key features:
- Compile individual functions to assembly, LLVM IR, or object code
- Get linkage names and module information
- Inspect number of captures and other function metadata
- Write compilation output to files
- Control compilation options and targets

Example:
```mojo
    from compile import compile_info

    fn my_func():
        print("Hello")

    # Get assembly for the function
    info = compile_info[my_func]()
    print(info.asm)
```
"""

from collections.string.string_slice import StaticString, _get_kgen_string
from os import PathLike
from pathlib import Path
from sys.info import _current_target

from memory import UnsafePointer

from utils import Writer

from .reflection import get_linkage_name

# ===-----------------------------------------------------------------------===#
# compile_info
# ===-----------------------------------------------------------------------===#


@value
@register_passable("trivial")
struct _Info:
    """A compiled closure implementation.

    Internal struct used to store compilation results from MLIR.

    Attributes:
        asm: The generated assembly/IR code as a string
        num_captures: Number of captured variables
    """

    var asm: __mlir_type.`!kgen.string`
    var num_captures: __mlir_type.index


@value
@register_passable("trivial")
struct _PopulateInfo:
    """A compiled populate closure implementation.

    This struct matches the type of the compiled closure type generated by
    `compile_offload`. Used internally for closure handling.

    Attributes:
        populate: Function pointer to populate captured variables
    """

    var populate: fn (__mlir_type.`!kgen.pointer<none>`) capturing -> None


@value
@register_passable("trivial")
struct Info[func_type: AnyTrivialRegType, func: func_type](
    Stringable, Writable
):
    """Contains compilation information and results for a function.

    Stores assembly/IR code, function metadata, and error information from
    compiling a function.

    Parameters:
        func_type: Type of the function being compiled.
        func: The function being compiled.

    Attributes:
        asm: Generated assembly/IR code
        function_name: Mangled function name
        module_name: Name of containing module
        num_captures: Number of captured variables
        populate: Function to populate captures
        error_msg: Error message if compilation failed
        is_error: Whether compilation had errors
    """

    var asm: StaticString
    """Generated assembly/IR code from the compilation process."""

    var function_name: StaticString
    """Mangled name of the compiled function, used for symbol resolution."""

    var module_name: StaticString
    """Name of the module containing the compiled function."""

    var num_captures: Int
    """Number of variables captured by the function closure."""

    alias populate = rebind[fn (UnsafePointer[NoneType]) capturing -> None](
        __mlir_attr[
            `#kgen.param.expr<compile_offload_closure,`,
            func,
            `> : `,
            _PopulateInfo,
        ].populate
    )
    """Function pointer to populate captured variables in the function closure."""

    var error_msg: StaticString
    """Error message if compilation failed, empty if successful."""

    var is_error: Bool
    """Flag indicating whether compilation encountered errors (True) or succeeded (False)."""

    @no_inline
    fn write_to[W: Writer](self, mut writer: W):
        """Writes the assembly/IR to a writer.

        Parameters:
            W: Type that implements the Writer interface for writing data.

        Args:
            writer: Writer object to write the assembly to.
        """
        return writer.write(self.asm)

    fn __str__(self) -> String:
        """Converts the assembly/IR to a string.

        Returns:
            The assembly/IR as a string.
        """
        return String.write(self)

    @no_inline
    fn write_text[path_like: PathLike](self, path: path_like) raises:
        """Writes the assembly/IR to a file.

        Parameters:
            path_like: Type that implements the `PathLike` interface for file path representation.

        Args:
            path: Path to write the file to.

        Raises:
            If file writing operations fail.
        """
        Path(path.__fspath__()).write_text(String(self))

    @no_inline
    fn __contains__(self, content: String) -> Bool:
        """Checks if content exists in the assembly/IR.

        Args:
            content: String to search for.

        Returns:
            True if content is found, False otherwise.
        """
        return content in String(self)


alias _EMISSION_KIND_ASM = 0
alias _EMISSION_KIND_LLVM = 1
alias _EMISSION_KIND_LLVM_OPT = 2
alias _EMISSION_KIND_OBJECT = 3


fn _get_emission_kind_id[emission_kind: StaticString]() -> Int:
    @parameter
    if emission_kind == "llvm":
        return _EMISSION_KIND_LLVM
    elif emission_kind == "llvm-opt":
        return _EMISSION_KIND_LLVM_OPT
    elif emission_kind == "object":
        return _EMISSION_KIND_OBJECT
    else:
        constrained[
            emission_kind == "asm",
            "invalid emission kind '",
            emission_kind,
            "'",
        ]()

        return _EMISSION_KIND_ASM


fn _noop_populate(ptr: UnsafePointer[NoneType]) capturing:
    """No-op populate function for closures without captures."""
    return


@always_inline
fn _compile_info_non_failable_impl[
    func_type: AnyTrivialRegType,
    func: func_type,
    /,
    emission_kind: Int,
    compile_options: StaticString,
    target: __mlir_type.`!kgen.target`,
]() -> Info[func_type, func]:
    """Internal implementation of compile_info that cannot fail.

    Parameters:
        func_type: Type of function to compile.
        func: Function to compile.
        emission_kind: Output format ID.
        compile_options: Compiler options string.
        target: Target architecture.

    Returns:
        Info struct containing compilation results.
    """
    var offload = __mlir_op.`kgen.compile_offload`[
        target_type=target,
        emission_kind = index(emission_kind),
        emission_option = _get_kgen_string[compile_options](),
        func=func,
        _type=_Info,
    ]()

    var result = Info[func_type, func](
        offload.asm,
        get_linkage_name[target, func](),
        # HACK: This is super low-level processing of !kgen.string values.
        # pop.string.hash should move to an attribute representation or
        # something.
        __mlir_op.`pop.string.hash`(offload.asm),
        offload.num_captures,
        "",
        False,
    )
    return result


@always_inline
fn compile_info[
    func_type: AnyTrivialRegType, //,
    func: func_type,
    /,
    *,
    emission_kind: StaticString = "asm",
    compile_options: StaticString = "",
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> Info[func_type, func]:
    """Compiles a function and returns detailed compilation information.

    This function takes a Mojo function and compiles it, providing access to the
    generated assembly code, linkage information, and other compilation artifacts.
    It can be used for inspection, debugging, and low-level optimization.

    Parameters:
        func_type: Type of the function to compile. Must be a trivially-copyable
            register type.
        func: The function to compile. Must match the specified func_type.
        emission_kind: The desired output format. Valid options are:
            - "asm": Assembly code (default).
            - "llvm": Unoptimized LLVM IR.
            - "llvm-opt": Optimized LLVM IR.
            - "object": Object code.
        compile_options: Additional compiler flags and options as a string.
        target: The target architecture to compile for. Defaults to current
            architecture.

    Returns:
        An `Info` struct containing:
        - asm: The generated code in the requested format
        - linkage_name: The mangled function name for linking
        - module_hash: A unique hash of the compiled module
        - num_captures: Number of captured variables
        - error: Any error message (empty if successful)
        - failed: Boolean indicating if compilation failed

    Example:

        ```mojo
        from compile import compile_info
        fn my_func():
            print("Hello")

        info = compile_info[my_func]()
        print(info.asm)  # Print assembly
        ```

    Note:
        The compilation is always performed, even if the function is not used.
        For performance-critical code, consider caching the compilation results.
    """
    return _compile_info_non_failable_impl[
        func_type,
        func,
        emission_kind = _get_emission_kind_id[emission_kind](),
        compile_options=compile_options,
        target=target,
    ]()
