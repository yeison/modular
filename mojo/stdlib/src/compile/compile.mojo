# ===----------------------------------------------------------------------=== #
#
# This file is Modular Inc proprietary.
#
# ===----------------------------------------------------------------------=== #
"""Provides utilities for compiling and inspecting Mojo code.

This module contains functionality for compiling Mojo functions and examining their
assembly, LLVM IR, or object code output. It is particularly useful for kernel
engineers who want to inspect the low-level implementation details of specific
functions without dealing with entire files or manual invocation of compilation
tools.

Key features:
- Compile individual functions to assembly, LLVM IR, or object code
- Get linkage names and module information
- Inspect number of captures and other function metadata
- Write compilation output to files
- Control compilation options and targets

Example:
    ```mojo
    from compile import compile_info

    fn my_func():
        print("Hello")

    # Get assembly for the function
    info = compile_info[my_func]()
    print(info.asm)
    ```
"""

from os import PathLike
from pathlib import Path
from sys.info import _current_target

from memory import UnsafePointer

from utils import Writer

from .reflection import get_linkage_name

# ===-----------------------------------------------------------------------===#
# compile_info
# ===-----------------------------------------------------------------------===#


@value
@register_passable("trivial")
struct _Info:
    """A compiled closure implementation.

    Internal struct used to store compilation results from MLIR.

    Attributes:
        asm: The generated assembly/IR code as a string
        num_captures: Number of captured variables
    """

    var asm: __mlir_type.`!kgen.string`
    var num_captures: __mlir_type.index


@value
@register_passable("trivial")
struct _PopulateInfo:
    """A compiled populate closure implementation.

    This struct matches the type of the compiled closure type generated by
    `compile_offload`. Used internally for closure handling.

    Attributes:
        populate: Function pointer to populate captured variables
    """

    var populate: fn (__mlir_type.`!kgen.pointer<none>`) capturing -> None


@value
@register_passable("trivial")
struct Info[func_type: AnyTrivialRegType, func: func_type]:
    """Contains compilation information and results for a function.

    Stores assembly/IR code, function metadata, and error information from
    compiling a function.

    Parameters:
        func_type: Type of the function being compiled.
        func: The function being compiled.

    Attributes:
        asm: Generated assembly/IR code
        function_name: Mangled function name
        module_name: Name of containing module
        num_captures: Number of captured variables
        populate: Function to populate captures
        error_msg: Error message if compilation failed
        is_error: Whether compilation had errors
    """

    var asm: StringLiteral
    var function_name: StringLiteral
    var module_name: StringLiteral
    var num_captures: Int
    alias populate = rebind[fn (UnsafePointer[NoneType]) capturing -> None](
        __mlir_attr[
            `#kgen.param.expr<compile_offload_closure,`,
            func,
            `> : `,
            _PopulateInfo,
        ].populate
    )
    var error_msg: StringLiteral
    var is_error: Bool

    @no_inline
    fn write_to[W: Writer](self, mut writer: W):
        """Writes the assembly/IR to a writer.

        Args:
            writer: Writer object to write the assembly to.
        """
        return writer.write(self.asm)

    fn __str__(self) -> String:
        """Converts the assembly/IR to a string.

        Returns:
            The assembly/IR as a string.
        """
        return String.write(self)

    @no_inline
    fn write_text[path_like: PathLike](self, path: path_like) raises:
        """Writes the assembly/IR to a file.

        Args:
            path: Path to write the file to.
        """
        Path(path.__fspath__()).write_text(String(self))

    @no_inline
    fn __contains__(self, content: String) -> Bool:
        """Checks if content exists in the assembly/IR.

        Args:
            content: String to search for.

        Returns:
            True if content is found, False otherwise.
        """
        return content in String(self)


alias _EMISSION_KIND_ASM = 0
alias _EMISSION_KIND_LLVM = 1
alias _EMISSION_KIND_LLVM_OPT = 2
alias _EMISSION_KIND_OBJECT = 3


fn _get_emission_kind_id[emission_kind: StringLiteral]() -> Int:
    constrained[
        emission_kind in ("llvm", "llvm-opt", "object", "asm"),
        "invalid emission kind '" + emission_kind + "'",
    ]()

    @parameter
    if emission_kind == "llvm":
        return _EMISSION_KIND_LLVM
    elif emission_kind == "llvm-opt":
        return _EMISSION_KIND_LLVM_OPT
    elif emission_kind == "object":
        return _EMISSION_KIND_OBJECT
    else:
        return _EMISSION_KIND_ASM


fn _noop_populate(ptr: UnsafePointer[NoneType]) capturing:
    """No-op populate function for closures without captures."""
    return


# (HACK, HACK, HACK), compile offload result is now a dynamic value
# instead of a compile time constant.
# The input of this function should not be treated as always
# a StringLiteral (compile time constant value).
# Mark this function as `always_inline` as a workaround to rely on
# compiler optimization to satisfy the input type requirement,
# but this is fragile.
@always_inline
fn _hash_module_name(s: StringLiteral) -> StringLiteral:
    return __mlir_op.`pop.string.hash`(s.value)


@always_inline
fn _compile_info_non_failable_impl[
    func_type: AnyTrivialRegType,
    func: func_type,
    /,
    emission_kind: Int,
    compile_options: StringLiteral,
    target: __mlir_type.`!kgen.target`,
]() -> Info[func_type, func]:
    """Internal implementation of compile_info that cannot fail.

    Parameters:
        func_type: Type of function to compile.
        func: Function to compile.
        emission_kind: Output format ID.
        compile_options: Compiler options string.
        target: Target architecture.

    Returns:
        Info struct containing compilation results.
    """
    var offload = __mlir_op.`kgen.compile_offload`[
        target_type=target,
        emission_kind = index(emission_kind),
        emission_option = compile_options.value,
        func=func,
        _type=_Info,
    ]()

    var result = Info[func_type, func](
        offload.asm,
        get_linkage_name[target, func](),
        _hash_module_name(offload.asm),
        offload.num_captures,
        "",
        False,
    )
    return result


@always_inline
fn compile_info[
    func_type: AnyTrivialRegType, //,
    func: func_type,
    /,
    *,
    emission_kind: StringLiteral = "asm",
    compile_options: StringLiteral = "",
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> Info[func_type, func]:
    """Compiles a function and returns detailed compilation information.

    This function takes a Mojo function and compiles it, providing access to the
    generated assembly code, linkage information, and other compilation artifacts.
    It can be used for inspection, debugging, and low-level optimization.

    Parameters:
        func_type: Type of the function to compile. Must be a trivially-copyable
            register type.
        func: The function to compile. Must match the specified func_type.
        emission_kind: The desired output format. Valid options are:
            - "asm": Assembly code (default).
            - "llvm": Unoptimized LLVM IR.
            - "llvm-opt": Optimized LLVM IR.
            - "object": Object code.
        compile_options: Additional compiler flags and options as a string.
        target: The target architecture to compile for. Defaults to current
            architecture.

    Returns:
        An `Info` struct containing:
        - asm: The generated code in the requested format
        - linkage_name: The mangled function name for linking
        - module_hash: A unique hash of the compiled module
        - num_captures: Number of captured variables
        - error: Any error message (empty if successful)
        - failed: Boolean indicating if compilation failed

    Example:
        ```mojo
        from compile import compile_info
        fn my_func():
            print("Hello")

        info = compile_info[my_func]()
        print(info.asm)  # Print assembly
        ```

    Note:
        The compilation is always performed, even if the function is not used.
        For performance-critical code, consider caching the compilation results.
    """
    return _compile_info_non_failable_impl[
        func_type,
        func,
        emission_kind = _get_emission_kind_id[emission_kind](),
        compile_options=compile_options,
        target=target,
    ]()


# ===-----------------------------------------------------------------------===#
# _internal_compile_code
# ===-----------------------------------------------------------------------===#


fn _internal_compile_code[
    func_type: AnyTrivialRegType, //,
    func: func_type,
    /,
    *,
    emission_kind: StringLiteral = "asm",
    compile_options: StringLiteral = "",
    target: __mlir_type.`!kgen.target` = _current_target(),
]() -> StringLiteral:
    """Compiles a function and returns the raw assembly/IR code.

    This is an internal utility function used by other compilation functions. It
    takes a function and compilation parameters and returns the generated code in
    the requested format.

    Parameters:
        func_type: Type of the function to compile. Must be a trivially-copyable
            register type.
        func: The function to compile. Must match the specified func_type.
        emission_kind: The desired output format. Valid options are:
            - "asm": Assembly code (default)
            - "llvm": Unoptimized LLVM IR
            - "llvm-opt": Optimized LLVM IR
            - "object": Object code
        compile_options: Additional compiler flags and options as a string.
        target: The target architecture to compile for. Defaults to current
            architecture.

    Returns:
        A string containing the generated code in the requested format (assembly,
        LLVM IR, or object code). The exact format depends on the emission_kind
        parameter.

    Note:
        This is an internal function and should not be called directly. Use the
        public compilation functions like `compile_info()` instead.
    """
    var info = compile_info[
        func,
        target=target,
        compile_options=compile_options,
        emission_kind=emission_kind,
    ]()
    return info.asm
